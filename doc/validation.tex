\subsection{Validation}
\subsubsection{Why do we need validation}
ErlangWeb like any other framework is a natural front end to existing systems that
communicates with human beings. It results with information exchange. All in all we need to
know type of data in the system. Even if we believe it is well formed and
comes from secure source, we need to render it somehow. Secondly, more important is
validating input values coming over HTTP from user.

\subsubsection{Expectations}
Set of types of the expected data from final user is declared in header file
representing \textit{custom type}. We already know 
that \textit{Validator} collects it and sends to proper functions
validating \textit{basic types}. Let's see it by example of code that is built
around the bookmark links.

\paragraph{Links records}
\begin{Verbatim}[fontsize=\small]
-record(link,{
              id,
              title,
              uri,
              text,
              category,
              new_cat
}).

-record(link_types,{
        id = {integer, [{description, "Link ID"},
			 {private, true},
			 {primary_key}]},
        title = {string, [{description, "Title"},
	                  {min_length, 1}]},
        uri = {string, [{description, "URI  http://"},
			 {min_length, 1}]},
        text = {text, [{description, "Description"},
	                {max_length, 255},
			{rows, 5},
			{cols, 40}]},
        category = {enum, [{description, "Category" },
                           {optional, ""}]},
        new_cat = {string, [{description, "New Category"},
                            {optional, ""}]}
}).
\end{Verbatim}

\paragraph{Including records} 
The simplest form of wtype file below. \\
Obligatory function \textbf{validate/1}

\begin{Verbatim}[numbers=left, fontsize=\small]
-module (wtype_link).

-export([validate/1, get_record_info/1]).

-include("../include/link_records.hrl").

get_record_info(link_types) -> #link_types{}
get_record_info(link) -> record_info(fields, link).


validate(From) -> 
    SuperField = get_record_info(link),
    SuperType = get_record_info(link_types),

    wpart_valid:validate(SuperField, SuperType, From ++ ["link"]).
\end{Verbatim}

String in line 15 is quite important for building default unique names. We use name
of custom type to let generic tools to recreate them. Function
get\_record\_info/1 is a space for dynamic changing types (e.g. on base of authentication). 

\paragraph{Validating an integer}
Our \textit{Link} type was analyzed and now incoming values from user are send
to validate functions of basic types. They are on framework side, but in case of adding new
type let's see example of {\it wtype\_integer}.

Obligatory function validate/1 has to be exported.
\nopagebreak
\begin{Verbatim}[numbers=left, fontsize=\small]
validate({Types,Input}) ->
    case wpart_valid:is_private(Types) of
	true ->
	    {ok, Input};
	false ->
	    case catch list_to_integer(Input) of 
		Int when is_integer(Int) -> 
		    case check_min(Int, Types) of
			{ok, Int} ->
			    case check_max(Int, Types) of
				{ok, Int} -> {ok, Int};
				ErrorMax -> ErrorMax
			    end;
			ErrorMin -> ErrorMin
		    end;
		_ -> {error, {not_integer, Input}}
	    end
    end.
\end{Verbatim}
In line 1 function takes arguments. They are sent by validator. It is always
a tuple \{Types, Input\}. {\it 'Types'} is a rewritten list from record
{\it link\_types}. Last important thing is specification of \textit{ok} and
\textit{error} result. Only format from lines 11 and 16 is valid.
\paragraph{Private field.} As a careful reader can see, there is a special case 
for private field in line 3. {\it Id} field in record link is private. It will not be visible
or editable for user and it will not be validated. 

\paragraph{Back to controller} Finally let's see how to call generic validation
from controller. Just code of date flow function and validate function.
\begin{Verbatim}[numbers=left]
  %...
 dataflow(create) -> [authenticate, validate, validate_logic];
  %...
 validate(create,_) ->
    validate_tool:validate_cu(link, create);
  %...
 error(create, not_valid) ->
	Err = wpart:fget("__error"),
 	Message = "ERROR: Incomplete input or wrong type in form!" ++
        "  Reason: " ++ Err,
	wpart:fset("error_message",Message),
    
	Not_validated = wtype_link:prepare_initial(),
	wpart:fset("__edit", Not_validated),
	{template, "templates/link/add_link.html"};
  %...
\end{Verbatim}
Any of calls for framework functions is not obligatory (we use in line 5 validation). We can easily create our
own validator and call it. What happens above? \textit{dataflow} makes
function validate to be called [3]. It uses framework tool to call and analyze
response from wpart\_valid [6]. On error dataflow makes sure that function
error/2 is called. It forms Error Message and fills form with initial values
(original input by user) - wrong rounded with red frame (style on CSS side -
obligatory class name {\it form\_error}).  

\paragraph{Special cases}
What if we want to use one record definition for many controllers and models,
which will interpret data differently? To achieve
that we need to export from model (wtype\textit{\_custom\_type})
\emph{get\_parent\_info/0} function.

\begin{Verbatim}
  -module(wtype_download).
  -export([get_parent_type/0]).
  %...some code
  get_parent_type() -> link.
\end{Verbatim}

\subsubsection{Validate\_tool}
In the example above we could see \emph{validate\_tool} in action. Let's take a closer
look at engine inside this module. 

\emph{Validate\_tool} was created to cooperate closely with
\emph{validator}. It is connected with data format returned by
\emph{validator}. Below is an example of such a list:\\
\begin{Verbatim}
 {error,[{{ok,[]},"link_new_cat"},
              {{ok,[]},"link_category"},
              {{error,{empty_input,undefined}},"link_text"},
              {{ok,"http://asd"},"link_uri"},
              {{ok,"VeryInterestingTitle"},"link_title"},
              {{ok,undefined},"link_id"}]}
\end{Verbatim}
Specification:
\begin{Verbatim}
{GlobalResult, ListResult}

ListResult = [ItemResult]
ItemResult = {Result, UniqueName}

GlobalResult = error | ok
Result = {ok, Input} | {error, ErrorCode}
ErrorCode = atom()
UniqueName = list()
\end{Verbatim}
To have full understanding of the input data \emph{validator} passes almost all
extracted and analized data. Handling it in each controller would be difficult.
That is why we need \emph{validate\_tool}.Its main functionality is to build
record and send it to controller. Next issue is handling
\emph{error} 'branch'. \emph{Validate\_tool} inserts all failed long unique names into request dictionary.
They are cought by \emph{wpart\_derived} and then error
frame is built. In the same time error atoms are collected and error message
string is set in dictionary. All of those information is handled by proper clause
of local \emph{error/2} function inside of controller.

