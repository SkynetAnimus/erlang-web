\section{Model. What happens in model it stays in model.}\label{model}
\subsection{Overview}
Model is a layer where all calls to data store are executed. Model file can be
easily identified - it should be in application folder and its name should have
prefix \emph{wtype\_}. It is consequence of mirroring types in records. In that
way \emph{wtype\_} file has additional functionality. 
\subsection{Specification}
\emph{Wtype\_} has to include type records and exports number of functions.
\\  \\
\begin{tabular}{l|l}
\emph{validate/1} &  handling validation of complex type  \\ \hline
\emph{get\_record\_info/1} & information about type for framework side
 modules;\\  
 &  must have 2 clauses \\ \hline
\emph{get\_parent\_info/1} & only in case of sharing type \\  
 & definition. Returns name of type which records are used.
\end{tabular}
\newline \\
All the other functions are called by controller, helpers, wparts so name
convention is not important (usually some of them are \emph{create}, \emph{read},
\emph{update}, \emph{delete} - to correlate with CRUD type of controller). 

\subsection{Example}
\subsubsection{Basics}
Lets take a look at example of model for users controller, which is
responsible for managing users accounts. \\
\begin{Verbatim}[frame=single,
       framesep=2mm,
       label=wtype\_users.ert,labelposition=topline,fontsize=\small,numbers=left]
-module(wtype_users).

-export([validate/1, get_record_info/1, get_parent_type/0]).
-export([create/1, delete/1, update/1, read/1]).
-export([prepare_initial/0]).

-include("../include/users_records.hrl").
-include_lib("stdlib/include/qlc.hrl").

get_record_info(users_types) -> #users_types{};
get_record_info(users) -> record_info(fields, users).

validate(From) -> 
    SuperField = get_record_info(users),
    SuperType = get_record_info(users_types),

    wpart_valid:validate(SuperField, SuperType, 
                         From ++ ["users"]).

create(User = #users{password = Password}) ->
    Bool = is_available(User),
  %% ..
\end{Verbatim}
Be carefull with line [18]. Name we are appening should be the same as type. 

\subsubsection{Dynamic type changes}
There are two ways of changing type dynamically. For example, if we want to send feed for
autocomplete type instead of defining tuple \{complete, "something1 $|$
something2" \} (see Ref. Manual).
in type records, we should use request dictionary (and place it in controller). \\
\begin{Verbatim}[frame=single,
       framesep=2mm, 
       label=controller.erl,labelposition=topline,fontsize=\small]
 wpart:fset("__types", [{account_id, {complete, wtype_users:get_accounts()}}]),
\end{Verbatim}
Wpart\_derived recognises key \emph{types} and extends field account\_id with
autocomplete proposals taken from database.
\\
The second way is more important in chapter about model. Let's change type by
modification of function \emph{get\_record\_info/1}.

\begin{Verbatim}[frame=single,
       framesep=2mm,,
       label=wtype\_link.erl,labelposition=topline,fontsize=\small,numbers=left]

%% ..all the necessary includes and exports

get_record_info(link_types) -> 
    C = #link_types{},
    {_Name, Raw} = C#link_types.category,
    Where = wpart:fget("__controller"),
    #group{categories = Cat_ids} = wtype_group:read(atom_to_list(Where)),
     Cat_str = lists:map(fun(X) -> 
				#category{title = XX} = wtype_category:read(X), 
				XX  
			 end, Cat_ids),
    Zipped = lists:zip(Cat_ids, Cat_str),
    ToGo =  string:join(
	      lists:map(fun({X,Y}) ->
				integer_to_list(X) ++ ":" ++ Y 
			end, 
			Zipped),
	      "|"),
    #link_types{category = {enum, Raw ++ [{choices, ToGo}]}};

get_record_info(link) -> record_info(fields, link).


validate(From) -> 
    SuperField = get_record_info(link),
    SuperType = get_record_info(link_types),

    wpart_valid:validate(SuperField, SuperType, From ++ ["link"]).

%% ..
\end{Verbatim}

What is done above - it is basically checking who called type Link (line [7]) and basing on
this information enum type (HTML radio buttons) is given some options.

Even more important is that we can put there any code and change type as we
like, e.g. authorization (session check). 
